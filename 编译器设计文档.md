## 编译器总体设计

顶层为`compiler`类，`Lexer`负责词法分析部分，`Parser`负责语法分析部分，`ErrorHandler`负责错误处理部分，`Visitor`类负责中间代码生成部分，`IOFiles`负责处理输入和输出部分。

​	首先`IOFiles`先处理`testfile.txt`的输入，将其转换为字符串传入`Lexer`类进行词法分析。`Lexer`类、`Parser`类、`Visitor`类分析结束后，再将最终分析结果通过`IOFiles`类输出至目标文件中。

​	词法分析部分以`Token`类作为最小单位，每个`Token`存储对应的`TokenType`、单词值和行号。`Lexer`类负责识别代码的各个单词并生成相应的`Token`类存储起来。

​	语法分析部分以`Node`类作为最小可识别单位。`Parser`类将`Lexer`类处理好的`Token`通过语法规则生成由各种`Node`节点组成的语法树。

​	错误处理部分，在`Parser`类进行语法分析时，同时进行错误处理判断，在有可能出现错误的部分调用`errorHandler`类进行错误检查，并将发现到的错误存储在该类中。当识别到错误时，并不会直接终止整个语法分析过程。符号表`SymbolTable`类是用来检测语义错误部分。

​	生成中间代码部分，利用`Visitor`类遍历语法树，再根据`LLVM IR`的规则生成对应的中间代码。在`LLVM IR`中，所有实体都被视为一个`Value`。





## 词法分析

词法分析阶段需要对testfile.txt里的内容进行读入和解析，输出每个单词的类别。

### 编码前设计

##### 架构设计 

1. Token类：表示词法分析器分析后的单词。
   - 记录输入的字符串（String）、单词类型（TokenType）、行号
   - 行号是为了过后在错误处理部分时用到的
2. TokenType（Enum类）：保存了Token的所有类型
3. Lexer类：遍历源代码，逐字符解析，生成对应Token，并把Token存入TokenList中
   - 记录当前遍历的字符串位置索引（curPos）、当前行号（lineNum）、当前字符串对应索引的符号（curChar）
   - curToken记录当前解析出的字符串内容
   - tokenList存储解析后的Token列表
   - 主要设计思想为：根据curPos从字符串中取出当前字符，判断当前字符属于什么类型。
     - 若当前字符为`'\n'` ，行号 +1，curPos+1，继续下一次循环
     - 若当前字符为 ` ' '` ,`'\t'` ，直接跳过继续下一次循环
     - 若当前字符为字母或下划线，调用`getString()`识别字符串类型。`getString()` 的逻辑为将`curChar`赋值给`curToken` 用于存储变量名或保留字。进入循环继续遍历源代码字符串，并且当前字符加入 `curToken` 中，直到当前字符不是字母、数字或下划线，退出循环。构造以`curToken`为单词内容的  `Token`。 
     - 若当前字符为数字，调用 `getNum()` 方法识别数字类型的标记。`getNum()` 的逻辑同`getString()` 逻辑相似，循环结束条件为当前字符不是数字。构造一个`INTCON`类型的`token` 。
     - 若当前字符为 `&` 或 `|`，可以直接确定逻辑运输符类型。但是这里还需要预留出现错误的情况，需往后读取下一个字符，确保没有出现错误。
     - 若当前字符为关系运算符 `<`, `>`, `!`, 或 `=`，并不能直接确定关系运算符的类型，因为有可能为`<`或`<=`，所以还需要调用 `getRelationType()` 方法，往后读取下一个字符来确定该符号类型。
     - 若当前字符为斜杠 `/`，调用 `getSlashType()` 方法，识别注释的类型。注释分为两种，`//` `/*--*/` ，若当前解析出的符号为 `//` , 进入单行注释，遍历直到遇到换行符 `\n`，`lineNum` 加一，然后退出注释。若当前解析出的符号为  `/*` ，进入多行注释，遍历直到遇到 `*/`，多行注释的结束。在遍历的过程中，若遇到换行符，同样将 `lineNum` 加一。
     - 若当前字符为双引号 `"`，调用 `getFormatString()` 方法识别格式化字符串类型的标记。 `getFormatString()` 中的逻辑为，将`curChar`赋值给`curToken`记录字符串内容，进入循环继续遍历源代码字符串，继续将`curChar`赋值给`curToken`，直到遇到双引号 `"` ，表示找到了字符串的结束位置。构造一个 `STRCON` 类型的 `token`，`curToken` 作为单词内容。
     - 若当前字符为加号 `+`、减号 `-`、百分号 `%`、或星号 `*`、分号 `;`、逗号 `,`、括号 `(` `)`、方括号 `[` `]`、或大括号 `{` `}`，可直接构造Token 并添加到 `tokenList` 中。
     - 若以上条件都不满足，表示遇到了不可识别的字符，调用 `error()` 方法处理错误。这里是为了过后的错误处理预留接口。



#### 编码后设计

基本上对于架构没什么很大的修改，添加了一些比较细节的处理部分。

1. 为了避免 `curPos`出现混乱的情况，我使用了 `getChar()` 和 `ungetChar()` 方法，使用  `getChar()`，将 `curChar` 设置为当前字符，然后将 `curPos`（当前位置）向后移动一位以获取下一个字符。当需要回退一个字符重新解析时，可以调用 `unGetChar()` 方法，将当前位置 `curPos` 回退一位，相当于撤销 `getChar()` 操作的移动。
2. 在debug过程中，发现若当前字符为斜杠 `/`时，除了可能为注释类型外，也有可能是 `/` 除号。
3. 关于行号的部分，除了在分析的最外层循环遇到 `\n` 时需要增加行号外，还需要在多行注释的循环中遇到 `\n` 也需要增加行号。
4. 在识别出字符串后还需要判断是否为关键词。



## 语法分析

语法分析阶段使用递归下降的方式对词法分析得到的`Token`类建立以`Node`为节点的语法树。

#### 编码前设计

##### 架构设计

1. `Node类`： 包含了规定文法里的每个元素。由于文法中出现左递归文法，对文法进行了修改。

   ```
   MulExp -> UnaryExp | MulExp ('*' | '/' | '%') UnaryExp 
   修改后：MulExp -> UnaryExp | UnaryExp ('*' | '/' | '%') MulExp
   
   AddExp -> MulExp | AddExp ('+' | '−') MulExp 
   修改后：MulExp | MulExp ('+' | '−') AddExp
   
   RelExp -> AddExp | RelExp ('<' | '>' | '<=' | '>=') AddExp 
   修改后：-> AddExp | AddExp ('<' | '>' | '<=' | '>=') MulExp 
   
   EqExp -> RelExp | EqExp ('==' | '!=') RelExp 
   修改后：-> RelExp | RelExp ('==' | '!=') EqExp 
   
   LAndExp -> EqExp | LAndExp '&&' EqExp 
   修改后：-> EqExp | EqExp '&&' LAndExp 
   
   LOrExp -> LAndExp | LOrExp '||' LAndExp 
   修改后：LOrExp -> LAndExp | LAndExp '||' LOrExp 
   ```

2. `Parser类`： 遍历`tokenList`的所有`token`，从`compUnit` 为根结点开始解析，根据语法规则解析逻辑，构建出完整的语法树。

   - `curToken`记录当前正在解析的`token`、`curPos`记录当前`Token`的索引

   - ```java
     CompUnit parseCompUnit();
     MainFuncDef parseMainFuncDef();
     Decl parseDecl();
     ConstDecl parseConstDecl();
     ConstDef parseConstDef();
     ConstInitVal parseConstInitVal();
     ConstExp parseConstExp();
     VarDecl parseVarDecl();
     VarDef parseVarDef();
     InitVal parseInitVal();
     FuncType parseFuncType();
     Btype parseBtype();
     FuncFParams parseFuncFParams();
     FuncFParam parseFuncFParam();
     Block parseBlock();
     BlockItem parseBlockItem();
     Stmt parseStmt();
     ForStmt parseForStmt();
     Cond parseCond();
     LOrExp parseLOrExp();
     LAndExp parseLAndExp();
     EqExp parseEqExp();
     RelExp parseRelExp();
     PrimaryExp parsePrimaryExp();
     LVal parseLVal();
     Exp parseExp();
     AddExp parseAddExp();
     MulExp parseMulExp();
     UnaryExp parseUnaryExp();
     FuncRParams parseFuncRParams();
     UnaryOp parseUnaryOp();
     Number parseNumber();
     ```

   - 各个解析方法通过检查当前`token`类型来判断当前`token` 属于哪种语法结构， 递归调用不同的解析函数，直到遇到最小的语法单元，提前预留遇到不符合规则可能会产生错误的接口。

     

#### 编码后设计

基本上对于架构没什么很大的修改，添加了一些比较细节的处理部分。

1. `Parser类`：某些元素的解析函数中包括了多种可能的组成部分、有些也不能直接根据当前`token`类型来判断应该调用哪些解析函数

   - `parseCompUnit()` : 

     ​	 `CompUnit -> {Decl} {FuncDef} MainFuncDef` ，在进入主函数前还会有无数个全局变量声明和函数定义。这里使用`while`循环来解析`tokenList`，直到遇到主函数为止。判断主函数、函数、变量声明并不能只检查当前`token`类型，因为他们的语法规则有着相似之处。这里就需要先预读后续几个 `token` 来判断当前该解析的是变量声明还是函数定义。

     ```java
     public CompUnit parseCompUnit() {
             //CompUnit -> {Decl} {FuncDef} MainFuncDef
           	...
             while (!isMainFunc()) {
                 if (curToken.getTokenType().equals(TokenType.INTTK) &&
                         preRead().getTokenType().equals(TokenType.IDENFR)) {
                         //有可能是int返回型函数或全局int类型变量
                     if (prePreRead().getTokenType().equals(TokenType.LPARENT)) {
                    			//确定是函数定义
                     } else if (prePreRead().getTokenType().equals(TokenType.ASSIGN) ||
                             prePreRead().getTokenType().equals(TokenType.SEMICN) ||
                             prePreRead().getTokenType().equals(TokenType.LBRACK) ||
                             prePreRead().getTokenType().equals(TokenType.COMMA)) {
                         // '[' || '=' || ',' || ';'
                        //确定是变量声明
                     } 
                 } else if (curToken.getTokenType().equals(TokenType.CONSTTK)) {
                     //const类型的变量声明
                 } else if (curToken.getTokenType().equals(TokenType.VOIDTK)) {
                     //void返回型的函数定义
                 } 
             }
             mainFuncDef = parseMainFuncDef();
             return new CompUnit(declList, funcDefList, mainFuncDef);
         }
     ```

   - `parseStmt()`:  

     - `LVal '=' Exp ';' ` , `LVal '=' 'getint' '(' ')' ';'  `,  `[Exp] ';'`   这3条语句的判断较复杂，由于`lval`和`Exp`的某些组成元素相同，为了避免出现回溯的情况，这里需要做较多的判断来确定属于哪一种情况的语法。
     - 大致逻辑为：首先调用`doLValinStmt()`判断是否存在赋值操作符 `=`。若存在，则执行 `LVal '=' Exp ';'` 或 `LVal '=' 'getint' '(' ')' ';'` 两种情况的语法分析，否则执行 `[Exp] ';'` 的语法分析。
     - `doLValinStmt()` 是用来判断是否为赋值语句的大致思路为，检查当前位置之后的`token`， 直到遇到分号为止，若在这范围内发现了等号`'='`，则为赋值语句。

   - `parseAddExp()`:

     - 修改文法后的解析思路：

       ```java
       private AddExp parseAddExp() {
               //AddExp → MulExp
               //AddExp → MulExp ('+' | '−') AddExp
               MulExp mulExp = parseMulExp();
               if (curToken.getTokenType().equals(TokenType.PLUS) || curToken.getTokenType().equals(TokenType.MINU)) {
               		... ...
                   AddExp addExp = parseAddExp();
                   return new AddExp(mulExp, op, addExp);
               }
               return new AddExp(mulExp);
          }
       ```

       - 在**代码生成部分**，再次修改了所有左递归文法，因为这样改会导致在做运算时出现前后顺序颠倒的情况。

         ```java
         private AddExp parseAddExp() {
                 //AddExp → MulExp {('+'| '-') MulExp}
                 MulExp mulExp = parseMulExp();
                 AddExp addExp = new AddExp(mulExp);
                 while (curToken.getTokenType().equals(TokenType.PLUS) || curToken.getTokenType().equals(TokenType.MINU)) {
                     ... ...
                     mulExp = parseMulExp();
                     addExp = new AddExp(mulExp, op, addExp);
                 }
                 return addExp;
             }
         ```

   - `preRead()` 和`prepreRead()`： 用来预读当前位置后面的一个或两个`token`，这样不会导致`curToken`的值变得混乱。

   - `setTokenAndNext()` ： 用来确保在每一次获取`token`值的同时也对`curPos`做了相应的处理。

2. `toString()` ：由于修改了左递归文法，在输出分析后的`node`时会出现不符合规定文法的输出。因此在输出这种包含左递归文法的节点时，为了保证符合输出要求，会在每个非终结符子节点遍历结束后输出当前的`Node`类。

   ```java
   //AddExp → MulExp
   //AddExp → MulExp ('+' | '−') AddExp
   public String toString() {
   	output.add(mulExp.toString());
   	output.add("<AddExp>");  //这里需要先输出当前的node类
   	if (midToken != null) {
   		output.add(midToken.toString());
   		output.add(addExp.toString());
   	}
   	return output;
   }
   ```





## 错误处理

错误处理阶段需要实现错误处理程序，发现程序中出现的语法和语义错误，并将所有出现的错误输出到`error.txt`文件中。

| 错误类型                             | 错误类别码 | 解释                                                         |
| :----------------------------------- | :--------: | :----------------------------------------------------------- |
| 非法符号                             |     a      | 格式字符串中出现非法字符报错行号为 **<FormatString>** 所在行数。 |
| 名字重定义                           |     b      | 函数名或者变量名在**当前作用域**下重复定义。注意，变量一定是同一级作用域下才会判定出错，不同级作用域下，内层会覆盖外层定义。报错行号为 **<Ident>** 所在行数。 |
| 未定义的名字                         |     c      | 使用了未定义的标识符报错行号为 **<Ident>** 所在行数。        |
| 函数参数个数不匹配                   |     d      | 函数调用语句中，参数个数与函数定义中的参数个数不匹配。报错行号为函数调用语句的**函数名**所在行数。 |
| 函数参数类型不匹配                   |     e      | 函数调用语句中，参数类型与函数定义中对应位置的参数类型不匹配。报错行号为函数调用语句的**函数名**所在行数。 |
| 无返回值的函数存在不匹配的return语句 |     f      | 报错行号为 **‘return’** 所在行号。                           |
| 有返回值的函数缺少return语句         |     g      | 只需要考虑函数末尾是否存在return语句，**无需考虑数据流**。报错行号为函数**结尾的’}’** 所在行号。 |
| 不能改变常量的值                     |     h      | <LVal>为常量时，不能对其修改。报错行号为 **<LVal>** 所在行号。 |
| 缺少分号                             |     i      | 报错行号为分号**前一个非终结符**所在行号。                   |
| 缺少右小括号’)’                      |     j      | 报错行号为右小括号**前一个非终结符**所在行号。               |
| 缺少右中括号’]’                      |     k      | 报错行号为右中括号**前一个非终结符**所在行号。               |
| printf中格式字符与表达式个数不匹配   |     l      | 报错行号为 **‘printf’** 所在行号。                           |
| 在非循环块中使用break和continue语句  |     m      | 报错行号为 **‘break’** 与 **’continue’** 所在行号。          |



#### 编码前设计

##### 架构设计

1. 构建符号表，符号表在错误处理阶段起着关键的作用，可以帮助检查存在的语义错误。

   - `VarSymbol类` ： 表示符号表中的变量符号，记录了变量指向的节点`Node`、变量名、变量的类型和维度。
   -  `FuncSymbol类`：表示符号表中的函数符号，记录了变量指向的节点`Node`、 函数名、函数的返回型、函数参数数量、函数的各种参数（类型）。
   - `SymbolTable 类`：实现程序的符号表，记录了每个作用域的所有变量`VarSymbol`和所有函数`funcSymbol`，记录循环状态和当前函数返回类型。
     - `curBlockId`：表示当前作用域块的id
     - `varSymbolsMapList` ：一个`HashMap类型`的`ArrayList` ，每一个`HashMap`表示了一个作用域，`HashMap`里存储作用域中的所有变量（包括函数定义也需要加入这个表中）。
     - `functionsMap`：存储函数符号`funcSymbol`的`HashMap`
     - `inLoop` ：循环状态管理，记录当前处在循环的第几层中，大于0表示在循环中，用于检查是否在循环块中使用`break` 和`continue`。
     - `curFuncType` : 记录当前函数的返回类型，用于检查有关返回值的错误。

2. 构造错误处理器

   - `ErrorType(Enum类)`： 保存错误的所有类别码。

   - `Error类`：表示发生的错误

     - 记录错误发生的行号和错误类型(ErrorType)

   - `ErrorHandler类`：错误处理器，可以检测可能发生的错误

     - 存储发现的所有错误(Error) 和 存储程序的符号表 (SymbolTable)

     - 存在检查所有类型错误的方法，若存在错误，获取错误出现的行号和错误类别码创建一个`Error`实体，加入`ErrorsList`。

       ```java
       public void checkErrorA(Token strcon) {
        // 检查格式字符串中是否存在非法字符。
       }
       
       public void checkErrorL(Stmt stmt, int printfLine) {
         //检查(printf)格式字符串中的格式字符是否与表达式数量匹配
         //从`stmt`节点中获取表达式列表的数量，再从 `stmt` 节点中取出字符串查找匹配`'%d'`的匹配项数。最后检查匹配数量是否一致就可以了。
       }
       
       public Boolean checkErrorB(String tokenName) {
         //检查变量是否可以被声明
       }
       
       public void checkErrorG(Node node) {
         //检查int返回型函数的最后一个语句是否为return
       }
       
       public void checkErrorH(LVal lval, int lvalLine) {
         //检查是否对常量变量进行赋值
       }
       
       public void checkErrorC(String tokenName, int lvalLine, int type) {
         //检查是否调用了未声明变量
         //type == 0 -> 普通变量 , type == 1 -> 函数
       }
       
       public void checkErrorD(String tokenName, FuncRParams funcRParams, int lValLine) {
         //检查函数调用时参数的数量是否与函数定义的参数数量匹配
       }
       
       public void checkErrorE(String tokenName, FuncRParams funcRParams, int lValLine) {
         //检查函数调用时传递的参数维度是否与函数定义的参数维度匹配
       }
       
       public void checkErrorM(int tokenLine) {
         //检查是否在循环语句之外使用了 break 或 continue
       }
       
       public void checkErrorF(Exp exp, int returnLine) {
         //检查void类型的函数的return是否合法
       }
       ```

       - `checkErrorA(Token strcon)`：检查格式字符串中是否存在非法字符。
       - `checkErrorL(Stmt stmt)`: 检查格式字符串中的格式字符是否与表达式数量匹配。从`stmt`节点中获取表达式列表的数量，再从 `stmt` 节点中取出字符串查找匹配`'%d'`的匹配项数。最后检查匹配数量是否一致就可以了。
       - `checkErrorB(String tokenName)`： 检查变量是否被声明过。
       - `checkErrorG(Node node)` ：

3. 在`Parser`类做语法解析的同时，进行符号表管理和错误管理。

   - 变量声明时，创建 `varSymbol` 并调用 `symbolTable` 的方法将变量符号加入当前作用域的符号表中
   - 函数定义， 创建`funcSymbol` 并调用 `symbolTable`的方法将函数符号加入函数表中。还需要根据函数名字转换 `varSymbol`，加入当前作用域的符号表中。在解析函数的参数时，也需要转换为`varSymbol`，加入新的一个作用域的符号表。
   - 解析一个新的`block`前，需要对`symbolTable`中的的方法给符号表添加一个新的作用域，`curBlockId` 和 `curFuncType` 也需要同时更新。
   - 对`Block`的解析结束时，调用`symbolTable`的方法，退出当前作用域，将对应的符号表删除。
   - 解析 `for` 类型的 `stmt` 时，调用 `symbolTable` 的方法记录进入循环状态；解析完了退出循环。
   - 在解析过程中，直接检查是否缺少右括号或分号。若缺少，调用`ErrorHandler`类，将错误信息添加到错误列表中。为了让解析程序继续，创建一个表示缺少元素的`token`，继续语法解析。
   - 变量声明或函数定义时，使用`ErrorHandler`类来检查是否出现重定义的错误。
   - 当解析到调用变量或函数的部分时，使用`ErrorHandler`类的错误检查方法来检查这些调用是否合法。（如调用前是否已被声明、函数参数数量是否匹配、函数参数类型是否匹配、是否对常量进行了赋值操作等）
   - 当解析到 `break` 或 `continue` 时，使用`ErrorHandler`类来检查是否处在循环中。
   - 当解析到`return`时，使用`ErrorHandler`类来检查是否为合法`return`。



#### 编码后设计

基本上对于架构没什么很大的修改，添加了一些比较细节的处理部分。

1. `SymbolTable`类 ： 在检查是否被声明时需要分为两种情况。调用变量时需要检查的是当前或之前作用域是否被声明过；而变量声明时需要检查的是当前作用域是否被声明过就可以了。

   - `isDefined(String tokenName)`: 变量调用时检查是否被声明过。

     ```java
     public Boolean isDefined(String tokenName) { 
       //是否被声明过（当前或之前）
     	for (int i = curBlockId; i >= 0; i--) {
     		HashMap<String, Symbol> varSymbolsMap = varSymbolsMapList.get(i);
         	if (varSymbolsMap.containsKey(tokenName)) {
                     return true;
           }
      	}
      return false;
     }
     ```

   - `canDefine(String tokenName)`：变量声明时检查在此作用域是否可以被声明。

     ```java
     public Boolean canDefine(String tokenName) { 
       //在当前作用域是否被声明过 
     		return !varSymbolsMapList.get(curBlockId).containsKey(tokenName);
     }
     ```

2. `VarSymbol类`：变量维度是在调用函数时检查函数实参类型时用的。

   - 维度依据变量后面跟着的方扩`'['`数量，a的维度为0，`a[1]`的维度为1，`a[1][2]`的维度为2。如果函数的实参是函数类型的，`int ` 型的维度为 0 ，`void`型的维度为-1。

   - `Boolean matchDim(int symbolDim, Token ident, int expDim)` ：用于检查函数实参类型是否匹配。主要逻辑为：

     - 若`Token`为`INTCON`型，参数实际维度为0，表示非数组整数。

     - 若实参是变量且不是函数调用，实际维度为，变量的维度减去`expDim`。

     - 若实参为函数调用，根据函数类型来设置实际维度。

     - 最后将实际维度和`symbolDim`进行比较。

       

3. `Parser类`：函数声明时对符号表的管理，确保及时将变量符号加入符号表，且是加入对的作用域。

   - 函数声明时对符号表的管理的步骤为：

     1. 若函数的名字未定义，代表函数声明成功，将函数添加到`varSymbol`符号表中。（在一开始就需要加入符号表了，因为可能出现递归的情况，若不及时加入符号表，当在解析函数内的语块时调用该函数将会出现函数未定义的情况）
     2. `symbolTable`进入新的作用域，同时根据函数类型设置当前函数类型。
     3. 解析函数的参数
     4. 创建`funcSymbol`，加入`funcSymbol`函数符号表。
     5. 解析函数体`Block`

     



## 代码生成

编译器中间代码：LLVM

### 阶段一

- 实现主函数与常量表达式的中间代码生成
- 实现全局变量和局部变量的中间代码生成
- 实现函数定义与调用

#### 编码前设计

##### 设计架构

![Screenshot 2023-12-13 at 12.29.52 AM](markdown-img/编译器设计文档.assets/Screenshot 2023-12-13 at 12.29.52 AM.png)

1. `IRModule` 类：表示中间代码的模块，属于最高级别的容器，包含了所有的`function`函数和`globalVar`全局变量。每个函数都包含了名称、参数、返回类型及至少一个 `BasicBlock` ，而 `BasicBlock` 中包含了很多条`Instruction`指令。

   - 在LLVM IR中，所有实体都被视为`Value`。`Value`包括了函数、全局变量、基本块、常量、字符串、指令等。

   - `type类`：用来表示`Value`的类型。

     - `VoidType`：void

     - `IntegerType` ： 表示整数值，有不同的位宽`(i1, i8, i32)`。

     - `ArrayType` ：表示数组类型，记录数组大小和元素类型`[length x i32]`。

     - `FunctionType `：表示函数类型，记录了返回类型和参数类型表。

     - ` LabelType`：表示语块类型，指`BasicBlock`。

     - ` PointerType `： 表示指针型，记录了指向的数据类型。

       

   - ![Screenshot 2023-12-13 at 1.20.06 AM](markdown-img/编译器设计文档.assets/Screenshot 2023-12-13 at 1.38.25 AM.png)

   - `Instruction`:

     | 指令      | 操作功能                                                     |
     | --------- | ------------------------------------------------------------ |
     | `Alloca`  | 为变量分配存储空间，返回一个指向该内存空间的指针。           |
     | `Load`    | 用于从内存中读取数据，并加载到变量中。                       |
     | `Store`   | 用于将数值或寄存器中的值存储到内存中的某个地址。             |
     | `Add`     | 执行加法操作                                                 |
     | `Sub`     | 执行减法操作                                                 |
     | `Mul`     | 执行乘法操作                                                 |
     | `Sdiv`    | 执行除法操作                                                 |
     | `Srem`    | 执行取模操作                                                 |
     | `GEPInst` | 用于获取指针所指向的特定元素或成员的地址，计算数据结构中元素的地址。 |
     | `Ret`     | 返回函数的执行结果                                           |
     | `Call`    | 调用函数                                                     |

   - ```java
     public class Value {
     		private String name; //value名字（寄存器名字、变量名字、函数名字、基本块名字）
     		private Type type; 
     		private static int REG_NUM_COUNT = 0;  //寄存器计数器，每一个函数的开始都会归0重新开始
     } 
     
     public class Argument extends Value {
       //函数参数类型
       //type -> 根据函数参数的类型
     }
     
     public class BasicBlock extends Value {
       private ArrayList<Instruction> instructionsList;
       //type -> labelType
     }
     
     public class User extends Value {
       private ArrayList<Value> operands; //引用的value  
     }
     
     public class Function extends User {
        private ArrayList<Argument> argumentsList; //记录参数
        private ArrayList<BasicBlock> basicBlocksList; //记录基本块
        private Boolean isLibrary; //区分是否为库函数 
       //库函数 declare 
       //函数定义 define dso_local
       //type -> functionType
     }
     
     public class GlobalVar extends User {
       public boolean isConst; //区分常量，变量
       //常量 dso_local constant
       //变量 dso_local global
       //type -> pointerType (指针型)
       //operands -> 存目标值
     }
     
     public class ConstInt extends User {
       private int intConst; //值
       //type -> integerType
     }
     
     public class ConstStr extends User {
       	//字符串存储为全局变量
      		private String strContent; //字符串内容
         private int length; //字符串长度
         //type -> ArrayType 
     }
     
     public class Instruction extends User {
       //指令
     }
     
     public class AllocaInst extends Instruction {
       //type -> pointerType  
     }
     
     public class LoadInst extends Instruction {
       //type -> pointerType指向的目标类型
     }
     
     public class StoreInst extends Instruction {
       //type -> voidType
     }
     
     public class BinaryInst extends Instruction {
       //只能相同类型的数值做运算
       //type -> 操作数的类型op1.type
     }
     
     public class GEPInst extends Instruction {
       //type -> 计算结束得到的值的类型
     }
     
     public class RetInst extends Instruction {
       //type -> voidType
     }
     
     public class CallInst extends Instruction {
       //type -> 函数的返回型
     }
     ```

     

2. `IRBuildFactory`类：用于构建LLVM指令的‘工厂’，提供生成`Instruction`的接口。

   ```
   public Function buildFunction();
   public GlobalVar buildGlobalVar();
   public ConstStr buildStr();
   public FunctionType buildFunctionType();
   public ArrayType buildArrayType();
   public ConstArr buildConstArr();
   public BasicBlock buildBasicBlock();
   public StoreInst buildStore();
   public RetInst buildRet();
   public BinaryInst buildBinaryInst();
   public Value buildConstInt();
   public Value buildVar();
   public Value buildLoadInst();
   public Value buildCallInst();
   public Value buildGEPInst();
   ```

   

3. `Visitor`类： 用于遍历语法树，`Visitor`类可以在不修改节点的情况下根据节点的类型和语义信息生成相应的中间代码。

   ```java
   //全局变量
   private IRModule irModule;
   private IRBuildFactory buildFactory;
   private ArrayList<HashMap<String, Value>> symbolValMap; //visitor类的符号表
   private int curSymbolValMapIndex = 0; //0->全局变量
   private Function curFunction;  //记录当前处于哪个函数
   private BasicBlock curBlock;  //记录当前基本块
   
   private Value curValue;  // 跟踪当前处理的Value
   private int curConst;  //跟踪当前处理的常量
   private TokenType curOp;  //跟踪当前操作类型
   private Type curType;  //跟踪当前数据类型
   
   private Boolean isAllConstant = false;  //记录当前节点应该为数字常量（int型）或为常量整数（value型）
   private Boolean isGlobal = false;  //是否为全局变量
   
   /*--------定义函数用--------*/
   private FunctionType curFuncType;  //跟踪函数类型
   private String curIdent;  //跟踪函数名字
   private Type curParamType;  //跟踪处理的参数类型
   private ArrayList<Type> argsList = new ArrayList<>(); //记录函数参数的类型
   private ArrayList<Value> argsValueList = new ArrayList<>();
   private ArrayList<String> argsIdentList = new ArrayList<>();
   /*------------------------*/
   
   ```



#### 编码后设计

1. `IRbuildFactory`:

   - 定义变量时：需要先用`alloca`指令分配内存，若变量有初始值用 `store` 指令将值存储到刚刚申请的地址中。

     ```java
      public Value buildVar(BasicBlock curBlock, Value curValue, Type varType) {
             ...
             AllocaInst allocaInst = new AllocaInst(varType);
        			if (有初始值) {
               StoreInst storeInst = new StoreInst(curValue, allocaInst)
             }
             
             ...
         }
     ```

2. `Visitor`：

   - `setInitFunction()`：添加库函数
   - `visitLValForAssign(LVal lVal)`：当前节点为`LVal`时，不同的`LVal`有不同的翻译方法。若翻译的`LVal`为被赋值状态，只需找到变量在符号表中的位置，并将其存储在 `curValue` 中，使用`store`指令将值存入`curValue`中。
   - `visitAddExp()`：若`isAllConst`为`true` ，表示需要计算常量表达式，计算结果应为常量。若`isAllConst`为`false` ，表示需要创建指令来处理运算操作。访问其他运算表达式的处理方式也相同。
   - `visitPrintfStmt()`：在处理待输出字符串时，需要先去除双引号和转义字符。接着再遍历字符串，`'%d'`调用`putInt()`函数、字符串调用`putStr()`函数，单个字符调用`putChar()`函数。

### 阶段二

- 条件语句
- 循环判断
- 数组与函数

#### 编码前设计

##### 设计架构

在阶段一的基础上添加了新的类来实现。

1. `IRModule` 类：没有修改

   - ![Screenshot 2023-12-13 at 7.28.36 PM](markdown-img/编译器设计文档.assets/Screenshot 2023-12-13 at 7.28.36 PM.png)

   - `Instruction`: 添加了新的指令

     | 指令   | 操作功能             |
     | ------ | -------------------- |
     | `Eq`   | 执行等于操作         |
     | `Neq`  | 执行不等于操作       |
     | `Sge`  | 执行大于等于操作     |
     | `Sgt`  | 执行大于操作         |
     | `Sle`  | 执行小于等于操作     |
     | `Slt`  | 执行小于操作         |
     | `And`  | 执行按位与操作       |
     | `Or`   | 执行按位或操作       |
     | `Br`   | 执行条件或无条件分支 |
     | `Zext` | 执行零扩展操作。     |

   - ```java
     public class ConstArr extends User {
       	//数组
      		private Boolean isInit; //是否已初始化
         //type -> ArrayType 
     }
     
     public class ICmpInst extends BinaryInst {
       //只能相同类型的数值做比较操作，比较结果为1位
       //type -> i1
     }
     
     public class BrInst extends Instruction {
       //有条件跳转、无条件跳转
       //type -> voidType
     }
     
     public class ZextInst extends Instruction {
       //type -> 扩展后的类型 i32
       
     }
     ```

     

2. `IRBuildFactory`类：添加新的接口。

   ```
   public ConstArr buildConstArr();
   public BinaryInst buildIcmpInst();
   public Value buildArrVar();
   public void buildBrInstWithCond();
   public void buildBrInstNoCond();
   public Value buildZextInst();
   ```

   

3. `Visitor`类：添加新的全局变量

   ```java
   //全局变量
    /*--------定义数组用--------*/
   private ArrayList<Value> arrayElements = new ArrayList<>(); //记录数组里的元素 （constInt 或 constArr）的形式
   private ArrayType arrayType2 = null; //二维数组中，{{},{},{}} 里面一层的数组类型
   private Boolean isInArray = false;  //是否在解析数组中
   /*------------------------*/
   
   /*--------- 分支语块----------*/
   private BasicBlock curTrueBlock = null;
   private BasicBlock curFalseBlock = null;
   private BasicBlock curFinalBlock = null;
   private ArrayList<BasicBlock> trueBlockStack; 
   private ArrayList<BasicBlock> falseBlockStack;
   private ArrayList<BasicBlock> finalBlockStack;
   private ArrayList<BasicBlock> curBlockStack;
   private ArrayList<BasicBlock> forTrueBlockStack;
   private ArrayList<BasicBlock> forEndBlockStack;
   private ArrayList<BasicBlock> forCondBlockStack;
   private ArrayList<BasicBlock> forStmt2BlockStack;
   /*-----------------------*/
   
   ```

   

#### 编码后设计

1. `Instruction`：

   - `GEPInst`指令的设计:

   ```java
   public GEPInst(Value basePointerAddr, ArrayList<Value> Indices) {
          	...
          	//计算得出的结果的值的类型
           int count = Indices.size();
           Type finalType =  basePointerAddr.getType().getElementType()
           for (int i = 1; i < count; i++) {
               finalType = finalType.getElementType();
           }
           this.setType(new PointerType(finalType));
           ...
       }
   ```

   - 

2. `BuildFactory`:

   - `buildICmpInst()` : 在执行`ICmpInst`前，需要确保参与比较的两个操作数为 `i32` 型。因此在每次要生成`ICmpInst`前，要先检查操作数的类型，若不符合就先构造`zext to`指令，来转换操作数的类型。

     ```java
     public BinaryInst buildIcmpInst(BasicBlock curBlock, TokenType curOp, Value value1, Value value2) {
             //icmp的结果是i1类型，两个操作数为i32类型
             if (!((IntegerType)value1.getType()).isInt32()) {
                 value1 = buildZextInst(curBlock, value1, new IntegerType(32));
             }
             if (!((IntegerType)value2.getType()).isInt32()) {
                 value2 = buildZextInst(curBlock, value2, new IntegerType(32));
             }
             ....
         }
     ```

   - 当遇到 `'!'`操作符时，可以构造一个等于0的比较指令。 

   - 定义数组变量时：若数组有被初始化，在分配一个内存空间后，使用`GEPInst` 指令根据数组元素逐个进行指针偏移到指定的位置后，再调用`Store`指令将对应的值存入对的数组位置。

     ```java
     public Value buildArrVar() {
     
             AllocaInst allocaInst = new AllocaInst(arrayType);       
             if (有初始值) {
                 //build gep n store
                
     						//偏移量的数组列表
                 //1->基地址 2->一维数组下标 3->二维数组下标
                 //a[2][1] = i32 0, i32 2, i32 1
                 ArrayList<Value> Indices = new ArrayList<>();
     						Indices.add(0).add(一维数组下标).add(二维数组下标);
                	gepInst = new GEPInst(allocaInst, Indices);
                 toreInst = new StoreInst(arrElement1,
     
         }
     ```

   - `buildBrWithCond()`： 执行条件分支，要确保`Cond`的类型为`i1`。

3. `Visitor`：

   - `visitLValForAssign(LVal lVal)`：若待赋值的`LVal`是数组，需进一步做处理。找到变量在符号表中相应的值后，根据对应的索引值创建`GEPInst`指令。若找到的值为指针型，需要先创建`Load`指令，加载该指针后才创建`GEP`。

   - `visitLVal(LVal lval)`：这个部分的处理非常复杂，需要考虑多种情况，`LVal`可能是简单变量、数组、或指针。针对数组或二维数组，在生成中间代码时（索引、加载指令）都需要考虑维度情况。针对指针类型，在生成中间代码时需要先进行加载操作，再进一步进行索引操作。

   - `if`分支语块的处理 : 使用栈来管理基本块。

     - `curBlockStack`：用于跟踪当前块。
     - `trueBlockStack`：用于存储 `if` 语句中条件为真的分支。
     - `falseBlockStack`：用于存储 `if` 语句中条件为假的分支。
     - `finalBlockStack`：用于存储 `if` 语句结束后的语块。
     - 对于基本块的推入和弹出的逻辑为：
       - 每当遇到`if`时，创建3个基本块，分别为`if`语句块、`else`语句块和结束语句块，将其推入对应的栈中。
       - 每当进入新的基本块时，将该基本块推入`curBlockStack`栈中，同时也将该栈从相应的栈中弹出。
     - 跳转指令的生成：
       - 当需要跳转到另一个基本块时，根据控制流生成无条件或有条件跳转指令，并将该基本块从`curBlockStack`中弹出。

   - 短路求值：

     - 逻辑或表达式
       - `if (a || b)`:  若第一个条件为真，表达式结果也为真，不需计算后续条件了。因此在处理这种情况时，两个条件不应该属于同一个基本块，需要创建一个新的基本块用来表示下一个条件，并将该基本块推入`falseBlockStack`中。这就可以确保只有第一个条件为假时才会执行第二个条件。
     - 逻辑与表达式
       - `if (a && b)`  ： 若第一个条件为假，表达式结果为假，不需计算后续条件了。因此处理这种情况时，同处理逻辑或表达式类似。此时表示第二个条件的基本块应该被推入`trueBlockStack`中。

     



## 总结

​		编译实验课终于要结束了。经过了15周的探索、学习、设计架构、编写代码、debug，历经千辛万苦我终于完成了一个可以生成中间代码LLVM的编译器。这段过程充满挑战，但同时也让我对编译原理有了更加深入的理解。

​		由于之前OO课也写过递归下降，因此在这词法分析和语义分析阶段，深入研究实验组给的文法后，就可以较轻松的完成词法分析器和语法分析器了。在语义分析和错误处理阶段，引入了符号表的概念。虽然在理论课上也学习了相关知识，但是真正上手写的时候才发现将理论知识转换为实践操作也不简单。通过实践，也让我巩固和加深了对这个部分的理解。

​		在代码生成部分，由于能力和时间原因，我并没有选择满分为100的mips。我选择了生成llvm中间代码，从对llvm零概念，到掌握LLVM的基本结构和用法我用了很多时间，所以也没有设计好架构就开始写了。我的架构也是在编码过程中写了又改，改了又写中完善好的。最后我也成功的完成了LLVM中间代码的转换。

​		在整个实验过程中，遇到了很多困难和问题。我觉得课程组提供的实验教程非常的有用处（虽然在实验初期我没有发现到这个部分><），这些教程可以帮助到不知道从何下手的同学，而且我觉得在中间代码部分的教程编排也非常的好，帮助了我很多。

​		这门课让我深刻体会到编译器设计与实现的复杂，也让我对编译器的设计有了更加深入的认识。虽然没有选择mips，没有去做优化，但是完成这个可以生成LLVM中间代码的编译器，对我来说也是一件很有成就感的事情了。最后感谢自己坚持下来，收获满满，也谢谢课程组对课程编排的用心。













